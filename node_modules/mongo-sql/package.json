{
  "name": "mongo-sql",
  "version": "2.5.6",
  "description": "A mongo-like interface for sql generation, postgres-style",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "mocha -R spec"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/goodybag/mongo-sql.git"
  },
  "keywords": [
    "postgres",
    "postgresql",
    "node-pg",
    "mongo",
    "sql"
  ],
  "author": {
    "name": "John Fawcett"
  },
  "license": "BSD",
  "devDependencies": {
    "mocha": "~1.12.0"
  },
  "readme": "# MoSQL - JSON to SQL\n\nPut value and _semantic meaning_ back into your queries by writing your SQL as JSON:\n\n[![NPM](https://nodei.co/npm/mongo-sql.png)](https://nodei.co/npm/mongo-sql/)\n\n```javascript\nvar builder = require('mongo-sql');\n\nvar usersQuery = {\n  type: 'select'\n, table: 'users'\n, where: { $or: { id: 5, name: 'Bob' } }\n};\n\nvar result = builder.sql(usersQuery);\n\nresult.values     // Array of values\nresult.toString() // Sql string value\n```\n\n___Result:___\n\n```sql\nselect \"users\".* from \"users\" where \"users.id\" = $1 or \"users\".\"name\" = $2\n```\n\nWant to play around with the syntax? Check out the [playground](http://mosql.j0.hn), [documentation](./docs), and [examples](#examples).\n\n__Installation:__\n\nNode.js:\n\n```\nnpm install mongo-sql\n```\n\nRequire.js:\n\n```\njam install mongo-sql\n```\n\n## Why JSON?\n\nThere are plenty of SQL building libraries that use a very imperative style of building SQL queries. The approach is linear and typically requires a bunch of function chaining. It removes your ability to use the query as a value and requires the library consumer to build their queries in large clumps or all at once. It's sometimes impossible with some of these libraries to reflect on the current state of the query programmatically. What columns have I added? Have I already joined against my groups table? MoSQL uses standard data structures to accomplish its query building, so you can figure out the state of the query at all times.\n\nThe reason we use standard JavaScript data structures is so everything is easily manipulated. Arrays are arrays and objects are objects. Everyone knows how to interface with them.\n\nJSON is also a prime candidate for becoming a universally understood data representation. By using Javascript objects, we do not rule out the possibility of interoping with and porting to other languages.\n\nIt may not be as pretty as other libraries, but prettiness is not a design principle of this library. The design principles are:\n\n__Extensibility__\n\nIf a feature is not supported, you should be able to add your own functionality to _make_ it supported.\n\n__Semantic Value__\n\nThe query should be represented in a manner that makes sense to developer and machine. The use of standard data structures allows the developer to use standard APIs to manipulate the query.\n\n## Examples\n\n```javascript\n{\n  type: 'create-table'\n, table: 'jobs'\n, definition: {\n    id:         { type: 'serial', primaryKey: true }\n  , user_id:    { type: 'int', references: { table: 'users', column: 'id' } }\n  , name:       { type: 'text' }\n  , createdAt:  { type: 'timestamp', default: 'now()' }\n  }\n}\n```\n\nSorry, these are in no particular order.\n\n* [Simple select](http://mosql.j0.hn/#/snippets/1)\n* [Simple insert](http://mosql.j0.hn/#/snippets/2)\n* [Insert with values from a select](http://mosql.j0.hn/#/snippets/16)\n* [Simple select with conditions](http://mosql.j0.hn/#/snippets/3)\n* [Joins](http://mosql.j0.hn/#/snippets/1b)\n* [Various conditional stuff](http://mosql.j0.hn/#/snippets/1j)\n* [Not in sub-query](http://mosql.j0.hn/#/snippets/4)\n* [Create view](http://mosql.j0.hn/#/snippets/5)\n* [Multi-row inserts](http://mosql.j0.hn/#/snippets/6)\n* [Ridiculous 'with' query with selecting JSON literal](http://mosql.j0.hn/#/snippets/e)\n* [Various column selection methods](http://mosql.j0.hn/#/snippets/w)\n* [Two different ways to specify a function](http://mosql.j0.hn/#/snippets/z)\n* [Rename column](http://mosql.j0.hn/#/snippets/11)\n* [Alias a table in select](http://mosql.j0.hn/#/snippets/12)\n* [Drop table](http://mosql.j0.hn/#/snippets/13)\n* [Create table](http://mosql.j0.hn/#/snippets/14)\n* [Select distinc](http://mosql.j0.hn/#/snippets/15)\n* [Update with increment](http://mosql.j0.hn/#/snippets/17)\n* [Group by](http://mosql.j0.hn/#/snippets/19)\n* [Various table specification methods](http://mosql.j0.hn/#/snippets/1d)\n* [Insert with sub-query as second value](http://mosql.j0.hn/#/snippets/1e)\n* [With sub-queries](http://mosql.j0.hn/#/snippets/1f)\n* [Adding a constraint with alter table](http://mosql.j0.hn/#/snippets/1h)\n* [Registering a conditional helper](http://mosql.j0.hn/#/snippets/1p)\n* [Updates increment decrement](http://mosql.j0.hn/#/snippets/1n)\n* [Expand foreign key array of integers to an array of JSON results](http://mosql.j0.hn/#/snippets/1t)\n* [Access Fields on HStore and JSON and casting](http://mosql.j0.hn/#/snippets/2y)\n\nFor even more examples, take a look at the `./tests` directory.\n\n## How does it work?\n\nEvery MoSQL query has a [query type](./docs/query-types.md) specified that maps to a SQL string template. Query types are composed of various strings and [query helpers](./docs/query-helpers.md) whose output maps to functions.\n\nSo ```type: 'select'``` uses the query type defined as 'select'. Every other property in the query object maps to a query helper. The 'select' query type starts off like this:\n\n```\n{with} select {columns} {table}...\n```\n\nWhen you have the following query:\n\n```javascript\n{ type: 'select', table: 'users' }\n```\n\nThe ```table``` property is mapped to the [table query helper](./docs/query-helpers.md#helper-table).\n\n98% of the functionality in MoSQL is defined through various helper interfaces. If the functionality you need doesn't exist, you can easily register your own behavior and keep on moving along. To see how all of the functionality was implemented, just check out the [helpers folder](./helpers). It uses the same API as library consumers to add its functionality.\n\n## Contributing\n\nI will happily accept pull requests. Just write a test for whatever functionality you're providing. Coding style is an evolving thing here. I'll be JSHinting this repo soon and will make the coding style consistent when I do.\n\n## Upgrading from 2.4.x to 2.5.x\n\nThere are two things you need to look out for:\n\nDo not rely on adding parenthesis to strings (like in columns or returning helpers) in order to prevent MoSQL from attempting to quote the input. Instead use the expression query type:\n\n```javascript\n// select something_custom - another_custom as \"custom_result\" from \"users\"\n{\n  type: 'select'\n, table: 'users'\n, columns: [\n    { expression: 'something_custom - another_custom', alias: 'custom_result' }\n  ]\n}\n```\n\nIf you were relying on expression objects without a type specified to be converted into a `function` type, this will no longer happen. Queries without types with `expression` specified in them will get converted to the new [expression type](./docs/query-types.md#type-expression).",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/goodybag/mongo-sql/issues"
  },
  "homepage": "https://github.com/goodybag/mongo-sql",
  "_id": "mongo-sql@2.5.6",
  "dist": {
    "shasum": "e9e2a05ba7e4ea1a184fa2b21a7147adf817e8e7"
  },
  "_from": "mongo-sql@",
  "_resolved": "https://registry.npmjs.org/mongo-sql/-/mongo-sql-2.5.6.tgz"
}
